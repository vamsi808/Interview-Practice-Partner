'use server';
/**
 * @fileOverview This file defines a Genkit flow for generating dynamic follow-up questions during a mock interview.
 *
 * The flow takes the previous question and the user's answer as input and generates a relevant follow-up question.
 * @module generate-dynamic-follow-up-questions
 * @exports generateDynamicFollowUpQuestions - The function to trigger the flow.
 * @exports GenerateDynamicFollowUpQuestionsInput - The input type for the generateDynamicFollowUpQuestions function.
 * @exports GenerateDynamicFollowUpQuestionsOutput - The output type for the generateDynamicFollowUpQuestions function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const GenerateDynamicFollowUpQuestionsInputSchema = z.object({
  previousQuestion: z.string().describe('The previous question asked by the interviewer.'),
  userAnswer: z.string().describe("The user's answer to the previous question."),
  jobRole: z.string().describe('The job role or job description the user is interviewing for.'),
  interviewState: z.enum(['questioning', 'closing']).describe("The current state of the interview. 'questioning' means you should ask another interview question. 'closing' means the main interview is over and you are handling the candidate's final questions."),
});
export type GenerateDynamicFollowUpQuestionsInput = z.infer<typeof GenerateDynamicFollowUpQuestionsInputSchema>;

const GenerateDynamicFollowUpQuestionsOutputSchema = z.object({
  followUpQuestion: z.string().describe('The dynamic follow-up question or concluding remark generated by the AI.'),
});
export type GenerateDynamicFollowUpQuestionsOutput = z.infer<typeof GenerateDynamicFollowUpQuestionsOutputSchema>;

export async function generateDynamicFollowUpQuestions(input: GenerateDynamicFollowUpQuestionsInput): Promise<GenerateDynamicFollowUpQuestionsOutput> {
  return generateDynamicFollowUpQuestionsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateDynamicFollowUpQuestionsPrompt',
  input: {schema: GenerateDynamicFollowUpQuestionsInputSchema},
  output: {schema: GenerateDynamicFollowUpQuestionsOutputSchema},
  prompt: `You are an experienced interviewer conducting a mock interview. The candidate is interviewing for the following role/job description:
  ---
  {{jobRole}}
  ---

  Current interview state: {{interviewState}}

  Previous Question from you: {{{previousQuestion}}}
  Candidate's most recent response: {{{userAnswer}}}

  {{#if (eq interviewState "questioning")}}
  Based on the previous question and the candidate's answer, generate a relevant and challenging follow-up question.
  If a detailed job description is provided above, ensure your question is directly related to the skills and responsibilities mentioned.
  The goal is to probe deeper into the candidate's experience, qualifications, and thought process.
  Your response should ONLY be the next question.
  {{/if}}

  {{#if (eq interviewState "closing")}}
  The main part of the interview is over. The candidate's response is a question for you or a closing remark.
  - If the user says "exit" or something similar, your response should be a simple, polite closing like "Thank you, goodbye."
  - If the user asks a question about the interview process, the role, or the company (hypothetically), provide a brief, helpful answer.
  - If the user asks a question about salary, specific benefits, or HR policies, politely deflect it by saying it's a great question for the HR team.
  - If the user provides a simple "no" or "no questions", respond with a final closing statement and tell them to say "exit" to finish. Example: "Alright, thank you for your time today. Just say 'exit' to conclude the session and view your feedback."
  Your response should be conversational.
  {{/if}}
  `,
});

const generateDynamicFollowUpQuestionsFlow = ai.defineFlow(
  {
    name: 'generateDynamicFollowUpQuestionsFlow',
    inputSchema: GenerateDynamicFollowUpQuestionsInputSchema,
    outputSchema: GenerateDynamicFollowUpQuestionsOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
